锁的分类：
   多个线程并发访问资源（Synchronized实现细节）
       无锁：不锁定资源，多线程访问只有一个能成功修改资源，其他线程会重试，基于CAS实现，多次同一访问，锁会升级为偏向锁
       偏向锁：适用于同一个线程多次访问的情况，会在对象头中存储ThreadID，每次加锁进行检查，如果ThreadID相同，则直接获取资源，不用重复加锁，多线程同时访问，会升级为轻量级锁
       轻量级锁：在偏向锁的阶段，如果多个线程同时访问，会撤销偏向锁，升级为轻量级锁，未获取到资源的线程会使用自旋获取锁
       重量级锁：自旋到达一定次数还未获取锁，锁膨胀为重量级锁，管理多个线程
   从资源已被锁定，线程是否阻塞
       阻塞：等待解锁重试
       不阻塞：
           自旋锁：
              实现：操作系统内核  TicketLock  CLHLock  MCSLock
              优点：不需要内核切换  短时间占用提升程序运行效率
              缺点：无法保证锁的公平性  长时间占用锁，浪费CPU
           适应性自旋锁：根据上次自旋锁定时间和锁状态决定
   根据锁是否重复获取：
       可重入锁
       不可重入锁
   多个线程能够共享一把锁：
       共享锁
       排它锁
   从线程是否需要对资源加锁：
       悲观锁：
           持有数据就会上锁
           实现： Synchronized  ReentrantLock
           适用场景： 根据实际业务情况
           缺点： 浪费CPU 执行效率低 占用资源，使其他线程无法工作
       乐观锁：
           持有数据不会上锁，写入时使用CAS判断
           实现：  版本号机制   CAS实现  java.util.concurrent.atomic
           适用场景：读多写少
           缺点： ABA问题   循环开销大
   锁的公平性区分：
           非公平锁：不会进行排队，插队获取锁   NonfairSync
           公平锁：轮流获取锁  FairSync

总结：
   从线程是否需要对资源加锁可以分为悲观锁和乐观锁
   从资源已被锁定，线程是否阻塞可以分为自旋锁
   从多个线程并发访问资源，也就是Synchronized可以分为无锁，偏向锁，轻量级锁和重量级锁
   从锁的公平性进行区分，可以分为公平锁和非公平锁
   从锁的是否可以重复获取可以分为可重入锁和不可重入锁
   从哪个多个线程能否获取同一把锁分为共享锁和排它锁

线程是否需要对资源加锁
   java按照是否对资源加锁分为乐观锁和悲观锁，乐观锁和悲观锁并不是一种真实存在的锁，而是一种设计思想，乐观锁和悲观锁对于理解java的多线程和数据库来说至关重要。

 悲观锁： 悲观锁是一种悲观思想，他总认为最坏的情况可能会出现，他认为数据很可能会被其他人所修改

   所以悲观锁在持有数据的时候总会把资源或者数据锁住，这样其他线程想要请求这个资源的时候就会阻塞，知道等到悲观锁把资源释放为止。

   传统的关系型数据库里面就用到了很多锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。悲观锁的实现往往依靠数据本身的锁功能实现。

   java中的Synchronized和ReentrantLock等独占锁（排它锁）也是一种悲观锁的思想的实现，因为Synchronized和ReetrantLock不管是否持有资源，他都会尝试去加锁。

 乐观锁：他认为资源和数据不会被别人所修改，所以读取不会上锁，但是乐观锁在进行写入操作的时候会判断当前数据是否被修改过

   乐观锁的实现方案一般来说有两种： 版本号机制 和 CAS实现。乐观锁多适用于多读的应用类型，这样可以提高吞吐量。

   在java中java.until.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。

两种锁的使用场景：
    一般来说，悲观锁不仅会对写操作加锁还会对读操作加锁，一个典型的悲观锁调用：
       select * from 表名 where name="cxuan" for update
     这条语句从表中将name="cxuan"的这条记录进行加锁处理，那么其他写操作在这个事务提交之前都不会对这条数据有影响，起到了排他和独占的作用。

    悲观锁因为对读写都加锁，所以他的性能比较低，对于现在互联网提倡的三高（高性能，高可用，高并发）来说，悲观锁的实现用的越来越少了

    但是一般多读的情况下还是需要使用悲观锁的，因为加锁虽然性能比较低，但是也阻止了想乐观锁一样，遇到写不一致的情况下一直重试的事件。

    相对而言，乐观锁用于读多写少的情况，即很少发生冲突的场景，这样可以省去锁的开销，曾增加系统的吞吐量。

    乐观锁的使用场景有很多，典型的比如说成本系统，柜员要对一笔金额做修改，为了保证数据的准确性和实效性，使用悲观锁锁住某个数据后，再遇到其他需要修改数据的操作，那么此操作就无法完成金额的修改，对产品说是灾难性的一刻，使用乐观锁版本号机制能够解决这个问题。

乐观锁的实现方式：

   版本号机制：
      版本号机制就是在数据表中加一个version字段来实现，表示数据被修改的次数

      当执行写操作并且写入成功后，version=version+1，当线程A要更新数据时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

    实例过程：
     第一种情况：
       事务一：进行写的操作，100+20=120，然后version进行+1。
       事务二：先读，得到数据=120和version=1，再进行写操作 120-50=70，version+1=2。

     第二种情况：
       事务一开启，进行读取金额和version，执行写操作
        begin
          update 表 set 金额 = 120,version=version+1 where 金额=100 and version=0
        此时金额改为120，版本号为1，事务还没有提交
       事务二开启，进行读操作，去除金额和版本号，执行写操作
        begin
          update 表 set 金额 =50，version=version+1 where 金额=100 and version=0
        此时金额改为50，版本号变为1，事务未提交

    现在提交事务一，金额改为120，版本变为1，提交事务。理想情况下应该变为金额=50，版本号=2，但是实际上事务二更新是建立在金额为100和版本号为0的基础上，所以事务二不会提交成功，应该重新读取金额和版本号，再次进行写操作，知道拿到正确的版本号，才能进行写操作，然后成功后将version+1.

CAS算法：
  CAS即compare and swap（比较与交换），是一种有名的无锁算法。即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步

  java从JDK1.5开始支持，java.util.concurrent包里面提供了很多面向并发编程的类，也提供了CAS算法的支持，一些以Atomic为开头的一些原子类都使用CAS作为其实现方式。使用这些类在多个CPU的机器上会有比较好的性能。

  如果要保证他们的原子性，必须进行加锁，使用Synchronized或者ReentrantLock。

  CAS中涉及三个要素：
    -需要读写的内存值V
    -进行比较的值A
    -拟写入的新值B
当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

CAS算法：
   会在不用锁的情况下保证线程安全。在多线程并行的情况下，使用AutomicInteger可以保证线程安全性。incrementAndGet和decrementAndGet都是原子性操作。

乐观锁的缺点：
  ABA问题：
    如果一个变量第一次读取的值是A，准备好需要对A进行写操作的时候，发现值还是A，那么这种情况下，能认为A的值没有被改变过吗？可以是由A->B->A的这种情况，但是AtomicInteger却不这么认为，只会相信自己看到的。

    jdk1.5以后的AtomicStampedReference类就提供了此种能力，其中的compareAndSet方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

    也可以采用CAS的一个变种DCAS来解决这个问题。DCAS,是对于每一个V增加一个引用的表示修改次数的标记符。对于每个V，如果引用修改了一次，这个计数器就加1.然后在再这个变量需要update的时候，就同时检查变量的值和计数器的值。

  循环开销大：
    我们知道乐观锁在进行写操作的时候会判断是否能写入成功，如果写入不成功将触发等待->重试机制，这种情况下也就是一个自旋锁，简单来说就是适用于短期内获取不到，进行等待重试的锁，它不适用于长期1获取不到锁的情况，另外，自旋循环对于性能开销比较大。

CAS与Synchronized的使用场景：

   简单来说CAS适用于写比较少的情况下（多读场景，冲突一般比较少），Synchronized适用于写比较多的情况下（多写场景，冲突一般比较多）

     *对于资源竞争比较少（线程冲突较轻）的情况下，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋的几率较少，因此可以获得更高的性能。
     *对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。

  Synchronized的补充：
     synchronized的底层实现主要依靠Lock-Free的队列，基本思路是自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但是获得了高吞吐量。在线程冲突较少的情况下，可以获得和cas类似的行嗯呢个；而线程冲突严重的情况下，性能远高于CAS。

资源已被锁定，线程是否阻塞

  自旋锁的提出背景

     由于在多处理器环境中某些资源的有限性，有事需要互斥访问，这时候就需要引入锁的概念，只有获取了锁的线程才能够对资源进行访问，由于多线程的核心就是CPU的时间分片，所以同一时刻只能有一个线程获取锁。

     那么就面临一个问题，那么没有获取到锁的线程应该怎么办？

     通常有两个处理方式：一种是没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁，这种锁叫做自旋锁，它不用将线程阻塞起来；还有一种处理方式就是把自己阻塞起来，等待重新调度请求，这种叫做互斥锁。

  什么是自旋锁？
    自旋锁的定义：当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取（占用），那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后再次尝试获取。这种采用循环加锁->等待的机制被称为自旋锁（spinlock）。

   thread-1 --------------------------------------->
      lock.lock();
      quick operations
      lock.unlock()

   thread-2 --------------------------------------->
      lock.lock()             try again
                              try again

      quick operations        acquired
           自旋锁获取示意图

自旋锁的原理
   如果持有锁的线程能在短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核和用户之间的切换进入阻塞状态，他们只需要等一等（自旋），等到持有锁的线程释放锁之后即可获取，这样就避免了用户进程和内核切换的消耗。

   因为自选锁避免了操作系统进程调度和线程切换，所以自旋锁通常适用在时间比较短的情况下。

   由于这个原因，操作系统的内核经常使用自旋锁。但是，如果长时间上锁的话，自旋锁会非常耗费性能，它阻止了其他线程的运行和调度。线程持有锁的时间越长，则持有该锁的线程会被调度程序中断的风险就越大。

   如果发生中断情况，那么其他线程将保持旋转状态（反复尝试获取锁），而持有该锁的线程并不打算释放锁，这样导致的结果是无限期推迟，直到持有锁的线程可以完成并释放它为止。

   上述解决方法，就是给自旋锁一个自旋时间，等时间一到就立即释放自旋锁。

   自旋锁的目的是占着CPU资源不进行释放，等到获取锁立即进行处理。

   选择自选时间的操作，如果自旋时间太长，会有大量的线程处于自旋状态占用CPU资源，进而影响整体系统的性能，因此自旋的周期选的很重要。

   jdk在1.6引入了适应性自旋锁，适应性自旋锁意味着自旋时间不是固定的了，而是由前一次在同一锁上的自旋时间以及锁拥有的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间。

自旋锁的优缺点
   自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！

   但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其他需要cpu的线程又不能获取cpu，造成cpu的浪费。所以这种情况下我们要关闭自旋锁。


自旋锁的实现：
   public class SpinLockTest {

    private AtomicBoolean available = new AtomicBoolean(false);

    public void lock(){
        //
        while (!tryLock()){
            System.out.println("获取锁");
        }
    }

    public boolean tryLock(){
        return available.compareAndSet(false,true);
    }

    public void unLock(){
        if (!available.compareAndSet(true,false)){
            throw new RuntimeException("释放锁失败");
        }
    }
}
这种简单的自旋锁有一个问题：无法保证多线程竞争的公平性。
 当多个线程想要获取锁时，谁最先将available设为false谁就能最先获得锁，这可能会造成某些线程一直都未获取到锁造成的线程饥饿。

通常我们会采取排队的方式解决这样的问题，类似地，我们把这种锁叫做排队自旋锁（QueuedSpinlock）

排队自旋锁的实现：Ticket，MCSLock，CLHock。

  TicketLock是一种同步机制或锁定算法，它是一种自旋锁，它使用ticket来控制线程执行顺序。
    TicketLock是基于先进先出（FIFO）队列的机制。它增加了锁的公平性，其设计原则如下：
       TicketLock中有两个int类型的数值，开始都是0，第一个值时队列ticket（队列票据），第二个值是出对（票据）。队列票据是线程在队列中位置，而出队票据是现在持有锁的票证的队列位置。就是队列票据是你取票号的位置，出队票据是你距离叫号的位置。

  代码实现：

public class TicketLock {

    //队列票据（当前排队号码）
    private AtomicInteger queueNum=new AtomicInteger();
    //出队票据（当前等待号码）
    private AtomicInteger dueueNum=new AtomicInteger();

    //获取锁；如果获取成功，返回当前线程的排队号
    public  int lock(){
        int i = dueueNum.incrementAndGet();

        while (i!=queueNum.get()){
            System.out.println("===");
        }
        return i;
    }

    //释放锁：传入当前排队号码
    public  void unLock(int ticketNum){
        queueNum.compareAndSet(ticketNum,ticketNum+1);
    }
}

 Synchronized的作用：
    1.原子性：synchronized保证语句块内操作时原子的
    2.可见性：synchronized保证可见性（通过“在执行unlock之前，必须先把此变量同步回主内存”实现）
    3.有序性：synchronized保证有序性（通过一个变量在同一个时刻只允许一条线程对其进行lock操作）
 Synchronized的使用：
    1.修饰实例方法，对当前实例对象加锁
    2.修饰静态方法，对当前类的Class对象加锁
    3.修饰代码块，对synchronized括号内的对象加锁
 Synchronized实现原理：
    1.jvm基于进入和退出Monitor对象来实现方法同步和代码块同步
     方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中，JVM可以从方法常量池中的方法表结构（method——info Structure）中的ACC_SYNCHRIONIZED访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会检查方法的ACC_SYNCRONIZED访问标志是否被设置，如果被设置了，执行线程将先持有montior（虚拟机规范中用的是管程一词），然后再执行方法，最后在方法完成（无论是正常完成还是非正常完成）时释放monitor。
     代码块的同步是利用monitorenter和moniterexit这两个字节码指令。他们分别位于同步代码块的开始和结束的位置。当jvm执行到monitorenter指令时，当前线程试图获取monitor对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器+1；当执行monitorexit指令时，锁计数器-1；当锁计数器为0时，该锁就会被释放了。如果获取monitor对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。
  注意：
    synchronized是可重入的，所以不会自己把自己锁死
    synchronized锁一旦被一个线程持有，其他试图获取该锁的线程将会被阻塞。

    2.Java对象头是实现synchronized的所对象的基础。一般而言，synchronized使用的锁对象是存储在java对象头里。它是轻量级锁和偏向锁的关键。
       -Mark Word
         Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode），GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等等。
       -Class Metadata Address
         类型指针，即是对象指向它的类元数据的指针来确定这个对象是哪个类的实例
       -Array length
         如果对象是一个java数组，那在对象头中还必须有一块用于记录数组长度的数据

       Monitor
         Monitor是一个同步工具，它内置于每个Object对象中，相当于一个许可证，拿到许可证可以进行操作，没有拿到则需要阻塞等待。

         在hotspot虚拟机中，通过ObjectMonitor类来实现minitor。

                  Monitor.Enter                   Monitor.Enter成功              Monitor.Exit
           ------------------------>监听器（Monitor）---------------->对象（Object）--------->
                                   |                |
                                   |                |
                                   |                |
                                   |                |
       Monitor.Exit后通知，出队列   |                |  Monitor.Enter失败
                                   |                |
                                   |                |
                                   |                |
                                   |                |
                                   |                |
                                   |                |
                                   同步队列（SynchronizedQueue）
wait和notify的原理
   调用wait方法，首先会获取监视器锁，获得成功以后，会让当前线程进入等待状态进入等待队列并且释放锁。
   wait方法的语义有两个，一个释放当前的对象锁，另一个是使得当前线成进入阻塞队列，而这些操作都和监视器是相关的，所以wait必须获得一个监视器锁。

   当其他线程调用notify后，会选择从等待队列中唤醒任意一个线程，而执行完notify方法以后，并不会立马唤醒线程，原因是当前线程仍然持有这把锁，处于等待状态的线程无法获得锁。必须要等到当前的线程执行完，按monitorexit指令以后，也就是锁被释放以后，处于等待队列中的线程就可以开始竞争锁了。

   而对于notify来说也是一样，它是唤醒一个线程，既然要去唤醒，首先得知道它在哪里，所以就必须要找到这个对象获取到这个对象的锁，然后到这个对象的等待队列中去唤醒一个线程。

