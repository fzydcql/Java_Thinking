### Redis是什么？

redis是nosql（也是个巨大的map）单线程，但是可处理1秒10w的并发（数据都在内存中）

使用java对redis进行操作类似jdbc接口标准对mysql，有各类实现它的实现类，我们常用的是druid。

### Redis篇

**Redis的好处：**

1. 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
2. 支持丰富数据类型，支持String，list，set，sorted set，hash
3. 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
4. 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除

**Redis相比memcached有哪些优势？**

1. memcached所有的值均是简单的字符串，redis作为替代者，支持更为丰富的数据类型
2. redis的速度比memcached快很多
3. redis可持久化数据

Redis常见性能为题和解决方案

1. Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件
2. 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次
3. 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内
4. 尽量避免在压力很大的主库上增加从库
5. 主从复制不要用网状结构，用单项链表结构更加稳定，即：Master<-Slave1<-Slave2<-Slave3...这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启动Slave1做Master，其他不变。

**MySql里有2000w数据，redis中只存有20w的数据，如何保证redis中的数据都是热点数据？**

相关知识：

redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。redis提供6种数据淘汰策略：

1. voltile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
2. volatie-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰
3. volatile-random：从已设置过期时间的数据集中任意选择数据淘汰
4. allkeys-lru：从数据集中挑选最近最少使用的数据淘汰
5. allkeys-random：从数据集中任意选择数据淘汰
6. no-enviction：禁止驱逐数据

**Memcache与Redis的区别都有哪些？**

1. 存储方式
   Memcahe把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。
   Redis有部分存在硬盘上，这样能保证数据的持久性。

2. 数据支持类型
   Memcache对数据类型支持相对简单

   Redis有复杂的数据类型

3. 使用底层模型不同
   它们之间底层实现方式 以及与客户端之间通信的应用协议不一样
   Redis直接自己构建VM机制，因为一般的系统调用系统函数的话，会浪费一定时间去移动和请求

4. value的大小
   redis最大可以达到1GB，而memcache只有1MB

**Redis常见的性能问题都有哪些？如何解决？**

1. Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。
2. Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件不断增大，AOF文件不断增大，AOF文件过大会影响Master重启的恢复速度。Mater最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化，如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。
3. Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。
4. Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网

**Redis的同步机制？**

主从同步  从从同步。第一次同步，主节点做一个bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。

**Redis集群，集群的原理是什么？**

Redis Sentinel着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。

Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。

### Redis持久化的几种方式-RDB深入解析

**1.持久化的几种方式：**

1. 快照方式（RDB，Redis DataBase）将某一时刻的内存数据，以二进制的方式写入磁盘；
2. 文件追加方式（AOF，Append Only File）记录所有操作命令，并以文本的形式追加到文件中；
3. 混合持久化方式  Redis4.0之后新增的方式，混合持久化是结合了RDB和AOF的优点，在写入的时候，先把当前的数据以RDB的形式写入文件的开头，再将后续的操作命令以AOF的格式存入文件，这样既能保证Redis重启时的速度，又能简单数据丢失的风险。

**2.RDB简介**

   RDB（Redis DataBase）是将某一时刻的内存快照（Snapshot），以二进制的方式写入磁盘的过程。

**3.持久化触发**

  RDB的持久化触发方式有两类：一类是手动触发，另一类是自动触发

1. 手动触发

​        手动触发持久化对的操作有两个：save和bgsave，它们主要区别体现在：是否阻塞Redis主线程执行。

- 在客户端执行save命令，就会触发Redis的持久化，但同时也是使RDB持久化完成，才会响应其他客户端发来的命令，所以在生产环境一定要慎用。当执行完save命令，持久化文件dump.rdb的修改时间就变了，这就表示save成功触发了RDB持久化。save命令执行流程。
- bgsave（background save）后台保存的意思，它和save命令最大的区别就是bgsave会fork（）一个子进程来执行持久化，整个过程中只有在fork()子进程时有短暂的阻塞，当子进程被创建之后，Redis的主进程就可以响应其他客户端的请求，相对于整个流程都阻塞的save命令来说，显然bgsave名轮毂更适合我们使用。

   2.自动触发

- save  m  n  
  save m   n是指m秒内，如果有n个建发生改变，则自动触发持久化。参数m和n可以在Redis的配置文件中找到。
  注意：当设置多个save m  n命令时，满足任意一个条件都会触发持久化。
- flushall
  flushall命令用于清空Redis数据库，在生产环境下一定慎用，当Redis执行flushall命令之后，则会触发自动持久化，把RDB文件清空。
- 主从同步触发
  在Redis主从复制中，当从节点执行全量复制操作时，主节点会执行bgsave命令，并将RDB文件发送给从节点，该过程会自动触发Redis持久化。

**4.配置说明**