### 线程安全：

**什么是线程安全？**

数据不同步

**如何解决？**

加同步使数据同步

**什么是多线程之间的同步？**

当多个线程共享一个资源，不会受到其他线程的干扰。

**同步代码块Synchronized**

synchronized（同一个数据）{

可能发生线程冲突的代码

}

**同步的前提？**

1.必须有两个或者以上的线程

2.必须是多个线程使用同一把锁

**同步的好处：**

解决了线程安全问题

**同步的弊处：**

较为消耗资源，效率低一些

**什么是同步方法？**

在方法上修饰synchronized称为同步方法

**同步方法使用的是什么锁？**

同步函数使用的this锁。

**什么是静态同步函数？**

在方法上修饰synchronized称为同步方法前加上一个static

这类函数使用的锁则是该函数所属字节码文件对象。

**什么是多线程死锁？**

同步中嵌套同步，导致锁无法释放

**ThreadLocal**

threadLocal提供一个线程的局部变量，访问某个线程拥有自己的局部变量。使得每个使用该变量的线程提供独立的变量副本。所以会有当每个修改自己的副本而不会去影响原来的模板。

ThreadLocal的接口方法：

- void set（Object value）设置当前线程的线程局部变量的值。
- public Object get（）该方法返回当前线程所对应的线程局部变量
- public void remove（）将当前线程局部变量的值删除，目的是为了减少内存的占用。

**ThreadLocal实现原理**

threadLocal通过map集合

map.put（“当前线程”，值）；

**多线程的三大特性**

原子性，可见性，有序性

**Java内存模型**

Jmm决定一个线程对共享变量的写入时，能否对另一个线程可见。

jmm定义了线程和主内存之间的抽象关系。

**Volatile**

可见性  可以保证被该修饰词修饰的变量，会在被修改的同时立即被更新到主内存。当其他线程需要读取时，可以立即获取修改之后的值。

可以保证可见性，但是无法保证原子性。

**volatile的特性：**

1.保证此变量对所有线程的可见性。

2.禁止指令重排序优化。

**volatile与Synchronized的区别：**

1.volatile可以保证可见性但是不能保证原子性。

2.性能方面，volatile性能会高于synchronized，但是却无法替代他。

**重排序**

就是程序在执行的时候，会自动在不改变结果的前提下，自己进行代码顺序的重新排序（最优排序）并执行的。