java的对象内存的分配：
   堆是线程共享的内存区域，栈是线程独享的内存区域。
   堆中主要存放对象实例，栈中主要存放各种基本数据类型，对象的引用。

对象存储方式：
   第一种方式：为了追求最大的执行速度，对象的存储空间和生命周期可以在编写程序时确定，这可以通过将对象置于堆栈（它们有时被称为自动变量或限域变量)或者静态存储区域内来实现。这种方式将存储空间分配和释放置于优先考虑的位置，某些情况下这样控制非常有价值。但是却因为在编写程序时知道对象确切的数量，生命周期和类型。
   第二种方式：是在被称为堆的内存池中动态的创建对象。在这种方式中，知道运行时才知道需要多少对象，它们的生命周期如何，以及它们具体类型是什么。这些信息只能在程序运行时相关代码被执行到那一刻才能确定。
   对于允许在堆栈上创建对象的语言，编译器可以确定对象存活的时间，也就是生命周期，并可以自动销毁它。也就是垃圾回收机制。防止内存泄漏。

java对象的内存分配过程是如何保证线程安全的?
   对象的内存分配过程中，主要是对象的引用指向这个内存区域，然后进行初始化操作。
 但是，因为堆是全局共享的，因此在同一时间，可能有多个线程在堆上申请空间那么，在并发场景中，如果两个线程先后把对象引用指向同一个内存区域。

 如何防止两个线程把对象引用指向同一个内存区域?
   为了防止两个线程把对象引用指向同一个内存区域，对象的内存分配就必须进行同步控制。但是我们都知道，无论
是使用哪种同步方案（实际上虚拟机使用的可能是CAS），都会影响内存的分配效率。    
   而Java对象的分配是Java中高频操作，所有，人们想到另外一个方法提升效率。HotSpot虚拟机方案：
      每个线程在Java堆中预先分配一小块内存，然后在给对象分配内存的时候，直接在自己这个"私有"内存中分配，当这部分区域用完之后，再分配新的"私有"内存.这个方案被称为TLAB分配，即Thread Local Allocation Buffer。这部分Buffer是从堆中规划出来的，但是是本地线程独享的。

什么是TLAB？
   TALB是虚拟机在堆内存的eden划分出来的一块专用空间，是线程专属的。在虚拟机的TLAB功能启动的情况下，在线程初始化时，虚拟机会为每个线程分配一块TLAB空间，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间分配，这样就不存在竞争的情况，可以大大提升分配效率。
   所以说，因为有了TLAB技术，堆内存并不是完完全全的线程共享，其eden区域中还有一部分空间是分配给线程独享的。

   注意：我们说TLAB是线程独享的，但是只是在"分配"这个动作上是线程独享的，至于在读取，垃圾回收等动作上都是线程共享的。而且在使用上也没有什么区别。
   

   也就是说，虽然每个线程在初始化时都会去堆内存中申请一块TLAB，并不是说这个TLAB区域的内存其他线程就无法访问了，其他线程读取还是可以的，只不过无法在这个区域分配内存而已。
   并且，在TLAB分配之后，并不影响对象的移动和回收，也就是说，虽然对象刚开始可能用过TLAB分配内存，存放在Eden去，但是还是会被垃圾回收或者被移动到Survivor Space ，Old Gen等。

   还有一点需要注意的是，我们说TLAB是在eden去分配的，因为eden区域本身就不算太大，而且TLAB空间内存也非常小，默认情况下仅占有Eden空间的1%。所以，必然存在一些大对象是无法在TLAB直接分配。

   遇到TLAB中无法分配的大对象，对象还是可能在eden区或者老年代等进行分配的，但是这种分配就需要进行同步控制，这也是为什么经常说：小的对象比大对象分配起来更加高效。

TLAB带来的问题？
   当线程的分配对象大于TLAB的内存时：
      1.如果一个对象需要的空间大小超过TLAB剩余的空间大小，则直接在堆内存中对该对象进行内存分配。
         问题：TLAB空间不足，导致后续需要分配的大多数对象都需要在堆内存直接分配。
      2.如果一个对象需要的空间大小超过TLAB剩余的空间大小，则可以废弃当前TLAB，重新申请TLAB空间再次进行内存分配。
         问题：频繁废弃TLAB，频繁申请TLAB，TLAB的分配过程其实也是需要并发控制的。而频繁的分配TLAB的就失去了使用的意义。
    两个问题解决方案：
       虚拟机定义一个refill_waste的值，这个值可以翻译为"最大浪费空间"。
       当请求分配的内存大于refill_waste的时候，会选择在堆内存中分配。若小于refill_waste，则会废弃TLAB，重新创建TLAB进行对象内存分配。

TLAB只是HotSpot虚拟机的一个优化方案。